


## 배경

## 절차

## 예시

다음은 예시를 위한 데이터로, 내 회사의 지점 사무실 정보를 CSV 형태로 정리한 것이다.

- office, country, telephone Chicago, USA, +1 312 373 1000 Beijing, China, +86 4008 900 505 Bangalore, India, +91 4064 9570 Porto Allegro, Brazil, +55 51 3079 3550 Chennai, India, +91 44 660 44766 ... (더 많은 데이터)

다음 함수는 인도 India에 자리한 사무실을 찾아서 도시명과 전화번호를 반환한다.

function acquireData(input) { const lines = input.split("\n"); - 컬렉션 let firstLine = true; const result = []; for (const line of lines) { 반복문 if (firstLine) { firstLine = false; continue; } if (Line.trim() == "") continue; const record = line.split(","); if (record[1].trim() == "India") { result.push({city: record[0].trim(), phone; record[2].trim()}); } } return result; }

이 코드의 반복문을 컬렉션 파이프라인으로 바꿔보자.

1. 첫 번째로 할 일은 반복문에서 사용하는 컬렉션을 가리기는 별도 변수를 새로 만드는 것이다. 이 변수를 루프 변수 alte라 하겠다.

function acquireData(input) { const lines = input.split("\n"); let firstLine = true; const result = []; const loopItems = lines for (const line of loopItems) { if (firstLine) { firstLine = false; continue; } if (line.trim() === "") continue; const record = line.split(","); if (record[1].trim() === "India") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }

2. 이 코드의 반복문에서 첫 if문은 CSV 데이터의 첫 줄을 건너뛰는 역할이다. 이 작업은slice() 연산을 떠올리게 한다. 자, 이 slice() 연산을 루프 변수에서 수행하고 반복문 안의if문은 제거하자.

function acquireData(input) { const lines = input.split("\n"); tet firsttine - true; const result = []; const loopItems = lines .slice(1); for (const line of loopItems) { if (firstline) firstline - false; continue; } if (line.trim() === "") continue; const record = line.split",");


if (record[1].trim() = "India") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }

이 단계에서 보너스로 firstLine 변수도 지울 수 있게 됐다. 제어용 변수를 지우는 일은 언제나 즐겁다.

반복문에서 수행하는 다음 작업은 빈 줄 지우기(trim)다. 이 작업은 filter() 연산으로 대체할 수 있다.

function acquireData(input) { const lines = input.split("\n"); const result = []; const loopItems = lines .slice(1) filter(line => line,trim() !== "") 5 for (const line of loopItems) { if (line. trim " continue; const record = line.split(","); if (record[1].trim() "India") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; )

파이프라인을 사용할 때는 문장 종료 세미콜론(;)을 별도 줄에 적어주면 편하다.

다음으로 map() 연산을 사용해 여러 줄짜리 CSV 데이터를 문자열 배열로 변환한다. 수정 전코드에서의 record라는 변수 이름은 적절치 않은데, 리팩터링을 안전하게 진행하기 위해 지금은 그냥 두고 나중에 수정하겠다.

= function acquireData(input) {

const lines = input.split("\n"); const result = [];

const loop Items = lines slice(1) .filter(line => line.trim() != "") .map(line => line.split("")) ; for (const line of loopItems) { const record = line;-split(","); if (record[1].trim() == "India") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }

다시 한번 filter() 연산을 수행하여 인도에 위치한 사무실 레코드를 뽑아낸다.

function acquireData(input) { const lines = input.split("\n"); const result = []; const loopItems = lines slice(1) filter(line => line.trim() != "") map(line => line.split(",")) filter(record => record[1].trim() === "India") 3 for (const line of loopItems) { const record = line; if record[1].trim() --- "India") { result.push({city: record[0].trim(), phone: record[2].trim()} } } return result; }

map()을 사용해 결과 레코드를 생성한다.

function acquireData(input) { const lines = input.split("\n"); const result = []; const loopItems = lines

);

.slice(1) filter(line => line.trim() != "") map(line => line.split(",")) .filter(record => record[1].trim() === "India") ..map(record => ({city: record[0].trim(), phone: record[2].trim()})) for (const line of loopItems) { const record = line; result.push(line); } return result; }

반복문이 하는 일은 이제 하나만 남있다. 바로 결과를 누적 변수에 추가하는 일이다. 3. 파이프라인의 결과를 누적 변수에 대입해주면 이 코드도 제거할 수 있다.

-function acquireData(input) {

const lines = input.split("\n"); const result = lines

slice(1) .filter(line => line.trim() !== "") . map(line => line.split",")) .filter(record => record[1].trim() == "India") . map(record => ({city; record[0].trim(), phone; record[2].trim()}))

5 for (const line of LoopItems) {

const record = line;

result.push(line); 7

return result; }

더 가다듬기

여기까지가 이번 리팩터링의 핵심이다. 하지만 코드를 좀 더 정리해보자. result 변수를 인라인하고, 람다 aniac 변수 중 일부의 이름을 바꾸고, 코드를 읽기 쉽도록 레이아웃을 표 형태로 정돈하면 다음처럼 된다.


function acquireData(input) { const lines = input.split("\n"); return lines .slice (1) .filter (line => line.trim() !== "") (line => line.split(",")) .filter (fields => fields[1].trim() === "India") .map (fields => ({city: fields[0].trim(), phone: fields[2].trim()})) .map 3 }

lines도 인라인할까 생각했지만, 그대로 두는 편이 코드가 수행하는 일을 더 잘 설명해준다고 판단하여 그대로 뒀다.

더 읽을거리

반복문을 파이프라인으로 대체하는 예를 더 보고 싶다면 내 블로그의 'Refactoring with Loops and Collection Pipelines를 참고하기 바란다.

https://martinfowler.com/articles/refactoring-pipelines.html


# 8.9 죽은 코드 제거하기 Remove Dead Code

if(false) {

doSomethingThatUsedToMatter(); }

## 배경

소프트웨어를 납품할 때, 심지어 모바일 기기용 소프트웨어라도 코드의 양에는 따로 비용을 매기지 않는다. 쓰이지 않는 코드가 몇 줄 있다고 해서 시스템이 느려지는 것도 아니고 메모리를 많이 잡아먹지도 않는다. 사실 최신 컴파일러들은 이런 코드를 알아서 제거해준다. 그렇더라도 사용되지 않는 코드가 있다면 그 소프트웨어의 동작을 이해하는 데는 커다란 걸림돌이 될 수 있다. 이 코드를 스스로는 '절대 호출되지 않으니 무시해도 되는 함수다'라는 신호를 주지 않기 때문이다. 그래서 운 나쁜 프로그래머는 이 코드의 동작을 이해하기 위해, 그리고 코드를 수정했는데도 기대한 결과가 나오지 않는 이유를 파악하기 위해 시간을 허비하게 된다.

코드가 더 이상 사용되지 않게 됐다면 지워야 한다. 혹시 다시 필요해질 날이 오지 않을까 걱정할 필요 없다. 우리에겐 버전 관리 시스템이 있다. 그러니 그런 날이 진짜로 온다면 그저 다시 살려내면 된다. 그런 날이 반드시 올 거라 생각된다면 어느 리비전에서 삭제했는지를 커밋 메시지로 남겨놓자. 하지만 솔직히, 내가 마지막으로 이렇게 했던 게 언제인지 기억도 나지 않으며, 이렇게 하지 않아서 후회한 기억도 없다.

한때는 죽은 코드를 주석 처리하는 방법이 널리 쓰였다. 버전 관리 시스템이 보편화되지 않았거나 아직은 쓰기 불편했던 시절에 유용한 방법이었다. 지금은 코드가 몇 줄 안 되는 초기 단계부터 버전 관리 시스템을 사용하므로, 더 이상은 필요치 않다.



Remove Dead Code 8.9 죽은 코드 제거하기

327


## 절차

1. 죽은 코드를 외부에서 참조할 수 있는 경우라면 (예컨대 함수 하나가 통째로 죽었을 때) 혹시라도 호출하는 곳이 있는지 확인한다.
2. 없다면 죽은 코드를 제거한다.
3. 테스트한다.
