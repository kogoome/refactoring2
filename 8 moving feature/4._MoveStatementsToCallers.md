# 8.4 문장을 호출한 곳으로 옮기기 Move Statements to Callers

- 반대 리팩터링: 문장을 함수로 옮기기5.3

```js
emitPhotoData(outStream, person.photo)

function emitPhotoData(outStream, photo) {
	outStream.write(`<p>25: ${photo.title}</p>\n`)
	outStream.write(`<p>131: ${photo.location}</p>\n`)
}
```
🔻
```js
emitPhotoData(outStream, person.photo)
outStream.write(`<p> 13): ${person.photo.Location}</p>\n`)

function emitPhotoData(outStream, photo) {
	outStream.write(`<p>19: ${photo.title}</p>\n`)
}
```

## 배경 <hr>
#### 
함수는 프로그래머가 쌓아 올리는 추상화의 기본 빌딩 블록이다. 그런데 추상화라는 것이 그 경계를 항상 올바르게 긋기가 만만치 않다. 그래서 코드베이스의 기능 범위가 달라지면 추상화의 경계도 움직이게 된다. 함수 관점에서 생각해보면, 초기에는 응집도 높고 한 가지 일만 수행하던 함수가 어느새 둘 이상의 다른 일을 수행하게 바뀔 수 있다는 뜻이다.

예컨대 여러 곳에서 사용하던 기능이 일부 호출자에게는 다르게 동작하도록 바뀌어야 한다면 이런 일이 벌어진다. 그렇다면 개발자는 달라진 동작을 함수에서 꺼내 해당 호출자로 옮겨야 한다. 이런 상황에 맞닥뜨리면 우선 문장 슬라이드하기를 적용해 달라지는 동작을 함수의

시작 혹은 끝으로 옮긴 다음, 바로 이어서 문장을 호출한 곳으로 옮기기 리팩터링을 적용하면 된다. 달라지는 동작을 호출자로 옮긴 뒤에는 필요할 때마다 독립적으로 수정할 수 있다.

작은 변경이라면 문장을 호출한 곳으로 옮기는 것으로 충분하지만, 호출자와 호출 대상의 경계를 완전히 다시 그어야 할 때도 있다. 후자의 경우라면 함수 인라인하기' 2부터 적용한 다음, 문장 슬라이드하기와 함수 추출하기 1실로 더 적합한 경계를 설정하면 된다.


## 절차 <hr>
#### 
1. 호출자가 적고 피호출 함수도 간단하면, 피호출 함수의 옮길 문장을 호출부로 옮기기. 테스트 통과시 종료
2. 복잡한 상황이라면, 이동하지 않길 원하는 문장을 임시 함수 추출
- 대상 함수가 서브클래스에서 오버라이드됐다면 오버라이드한 서브클래스들의 메서드 모두에서 동일하게, 남길 부분을 메서드로 추출한다. 이때 남겨질 메서드의 본문은 모든 클래스에서 똑같아야 한다. 그런 다음 (슈퍼클래스의 메서드만 남기고) 서브클래스들의 메서드를 제거한다.
3. 원래 함수를 인라인
4. 추출된 함수의 이름을 원래 함수의 이름으로 변경
- 더 나은 이름이 떠오르면 그 이름을 사용하자.