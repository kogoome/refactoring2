CHAPTER 04

테스트 구축하기

리팩터링은 분명 가치 있는 도구지만, 그것만으로는 부족하다. 리팩터링을 제대로 하려면 불가피하게 저지르는 실수를 잡이주는 견고한 테스트 스위트 test Suit가 뒷받침돼야 한다. 자동 리팩터링 도구를 활용하더라도 이 책에서 소개하는 리팩터링 중 다수는 테스트 스위트로 재차 검증해야 할 것이다.

이게 단점은 아니다. 리팩터링을 하지 않더라도 좋은 테스트를 작성하는 일은 개발 효율을 높여준다. 테스트 작성에 시간을 빼앗기는데 효율이 높아진다니? 직관에 이긋나는 효과라서 나도 (다른 프로그래머들처럼) 처음 깨달았을 때는 상당히 놀랐다. 자, 그럼 효율이 좋아지는 이유를 함께 살펴보자.

4.1 자가 테스트 코드의 가치

프로그래머들이 어떻게 일하는지 가만히 살펴보면 실제로 코드를 작싱하는 시간의 비중은 그리 크지 않음을 발견할 수 있다. 현재 상황을 파악하기도 하고, 설계를 고민하기도 한다. 물론대부분의 시간은 디버깅에 쓴다. 여러분도 디버깅하느라 밤늦게까지 고생한 경험이 있을 것이다. 프로그래머라면 누구나 꼬박 하루를 (혹은 그 이상을) 잡아먹은 디버깅 무용담을 하나씩은 간직하고 있을 것이다. 버그 수정 자체는 대체로 금방 끝난다. 진짜 끔찍한 건 버그를 찾는여정이다. 또한 버그를 잡는 과정에서 다른 버그를 심기도 하는데, 그 사실을 한참이 지나서야알아채기도 한다. 그래서 또다시 그 버그를 찾느라 수많은 시간을 날린다.

page(133)

내가 자가 테스트 코드를 진지하게 고민하기 시작한 계기는 1992년 OOPSLA 곤퍼런스에서발표하던 중 겪은 일 때문이다. 한장 발표하고 있는데 누군가 "클래스마다 테스트 코드를 갖춰야 한다"는 말을 툭 던졌다 (내 기억에 “베다라" 데이브 토마스 "Bedara" Dave Tomas 였던 것 같다). 그때부터 나는 코드베이스에 프로덕션 코드와 테스트 코드를 함께 담기로 했다. 당시 반복적 개발 방법론 (iterative development)을 따르고 있었기 때문에 반복 주기가 하나 끝날 때마다 가능하면테스트 코드도 추가했다. 당시 내가 참여한 프로젝트는 규모가 작은 편이어서 반복 주기는 1주 정도였다. 테스트 작업은 꽤 쉽고 간단했지만 상당히 지루했다. 테스트 코드가 콘솔에 출력한 결과를 일일이 눈으로 확인해야 했기 때문이다. 난 상당히 게을러서 일을 줄이는 작업이라면 얼마든지 감수할 각오가 돼 있다. 그래서 프로그램이 제대로 된 값을 출력했는지 내가 직접확인하지 말고, 그 일을 컴퓨터에 맡겨야겠다고 생각했다. 테스트가 성공했는지 확인하려면 의도한 결과와 테스트 결과가 같은지만 비교하면 된다. 그래서 모든 테스트가 성공하면 화면에“OK”만 출력하도록 만들었다. 이렇게 자가 테스트 소프트웨어가 탄생했다.

모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자.

이렇게 하니 테스트가 컴파일만큼 쉬워졌다. 그래서 다음부터는 컴파일할 때마다 테스트도 함께 했고, 곧바로 생산성이 급상승했다. 디버깅 시간이 크게 줄어든 것이다. 가장 최근 테스트로 잡은 버그를 다시 살려보면 테스트에 걸려 눈에 확 드러난다. 직전까지 테스트가 성공했다면 마지막 테스트 이후에 작성한 코드에서 버그가 발생했음을 알 수 있다. 이런 테스트를 몇 분간격으로 자주 수행했기 때문에 버그가 발생한 지점은 조금 전에 작성한 코드에 있다는 사실도 알 수 있었다. 의심되는 코드의 양이 많지 않고 아직 기억이 생생하니 버그를 쉽게 찾을 수 있었다. 이렇게 하지 않았다면 몇 시간이 걸렸을지 모를 버그를 단 몇 분이면 해결할 수 있었다.이처럼 자가 테스트 코드 자체뿐 아니라 테스트를 자주 수행하는 습관도 버그를 찾는 강력한도구가 된다.

이 사실을 깨달은 후로 나는 테스트에 더 적극적으로 나섰다. 반복 주기가 끝나길 기다리지 않고 함수 몇 개만 작성해도 곧바로 테스트를 추가하기 시작했다. 매일 두어 개의 새로운 기능과그에 딸린 테스트 코드가 쌓여갔다. 그래서 회귀 버그regression bug*를 잡는 데 몇 분 이상 걸린 적이 거의 없다.

테스트 스위트는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다.

*회귀 버그란 잘 작동하던 기능에서 문제가 생기는 현상을 가리키며, 일반적으로 프로그램을 변경하는 중 뜻하지 않게 발생한다. 같은 맥락에서, 잘 직동하던 기능이 여전히 잘 작동하는지 확인하는 테스트를 회귀 테스트(regression test)라 한다.

page(134)

이 경험 이후로 자가 테스트 코드를 작성하고 구성하는 수고를 덜어주는 도구들이 급격히 발전했다. OOPSLA 1997에 참석하기 위해 스위스에서 애틀랜타로 향하는 비행기에서 켄트벡은 에릭 감마Erich Gamma와 함께 자신이 구현한 스몰토크 버전 단위 테스트 프레임워크를 자바로 포팅했다. 그 결과로 나온 것이 바로 JUnit 이유이다. JUnit은 프로그램 테스트 분야에 지대한 영향을 끼쳤고, 수많은 언어용으로 비슷한 도구*가 만들어지는 데 밑거름이 됐다.

사실 다른 사람에게 이런 식으로 개발하라고 설득하기는 녹록지 않다. 테스트를 작성하려면 소프트웨어 제품 본체 외의 부가적인 코드를 상당량 작성해야 한다. 그래서 테스트가 실제로 프로그래밍 속도를 높여주는 경험을 직접 해보지 않고서는 자가 테스트의 진가를 납득하긴 어렵다. 게다가 테스트 작성법을 배운 적이 없는 프로그래머가 많을뿐더러, 테스트에 대해 생각조차 못 해본 이도 많다. 테스트를 수동으로 하면 좀이 쑤실 정도로 지겹다. 하지만 자동화한다면테스트 코드를 작성하는 재미가 꽤 쏠쏠하다.

테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 나는 기능을 추가해야 할때 테스트부터 작성한다. 얼핏 순서가 뒤바뀐 듯 들리지만, 전혀 그렇지 않다. 테스트를 작성하다 보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다. 구현보다 인터페이스에집중하게 된다는 장점도 있다(무조건 좋은 일이다). 게다가 코딩이 완료되는 시점을 정확하게판단할 수 있다. 테스트를 모두 통과한 시점이 바로 코드를 완성한 시점이다.

켄트 벡은 이처럼 테스트부터 작성하는 습관을 바탕으로 테스트 주도 개발 Test-Driven Development(TDD)**이란 기법을 창시했다. TDD에서는 (처음에는 통과하지 못할) 테스트를 작성하고,이 테스트를 통과하게끔 코드를 작성하고, 결과 코드를 최대한 깔끔하게 리팩터링하는 과정을짧은 주기로 반복한다. 이러한 테스트-코딩 - 리팩터링 과성을 한 시간에도 여러 차례 진행하기 때문에 코드를 대단히 생산적이면서도 차분하게 작성할 수 있다. TDD에 대해서는 여기서자세히 설명하지 않지만, 내가 프로그래밍하는 방식이자 추천하는 방식이다.

이 정도면 테스트가 중요한 이유는 충분히 설명한 것 같다. 자가 테스트 코드를 작성하면 누구나 효과를 볼 수 있다고 굳게 믿지만, 이 책의 주제는 어디까지나 리팩터링이다. 리팩터링에는테스트가 필요하다. 그러니 리팩터링하고 싶다면 테스트를 반드시 작성해야 한다.

이번 장에서는 자바스크립트 프로그램용으로 테스트 코드를 작성하는 방법을 소개한다.

* https://martinfowler.com/bliki/Xunit.html
** https://martinfowler.com/bliki/TestDriven Development.html


page(135)


테스트가 주제인 책이 아닌 만큼 깊게 들어가지는 않겠다. 하지만 아주 적은 노력으로 엄청난 효과를 볼 수 있음을 명심하자.

이 책의 스타일대로, 테스트 기법도 예시 중심으로 소개하겠다. 나는 코드를 작성할 때 테스트도 동시에 작성한다. 하지만 간혹 테스트가 갖춰지지 않은 코드를 리팩터링해야 할 때도 있다. 그럴 때는 곧바로 리팩터링하지 않고, 먼저 자가 테스트 코드부터 작성한다.

4.2 테스트할 샘플 코드

우선 테스트 대상이 될 코드를 살펴보자. 이 코드는 사용자가 생산 계획을 검토하고 수정하도록 해주는 간단한 애플리케이션의 일부다. UI는 (좀 투박하지만) 다음과 같다.

지역:Asia
수요:30 가격:20
생산자 수: 3
Byzantium:
  비용:10 생산량:9 수익:90
Attalia:
  비용:12 생산량:10 수익:120
Sinope:
  비용:10 생산량:6 수익:60

부족분:5 총수익:230

생산 계획은 각 지역prounce의 수요enand 와 가격Price으로 구성된다. 지역에 위치한 생산자 producer들은 각기 제품을 특정 가격으로 특정 수량만큼 생산할 수 있다. UI는 생산자별로 제품을 모두 판매했을 때 얻을 수 있는 수익ill reunite도 보여준다. 화면 맨 아래에는 (수요에서 총생산량을 뺀) 생산 부족분ntal과 현재 계획에서 거둘 수 있는 총수익 profi도 보여준다. 사용자는 UI에서 수요. 가격, 생산자별 생산량iluttin과 비용을 조정해가며, 그에 따른 생산 부족분과 총수익

page(136)


을 확인할 수 있다. 사용자가 화면에서 숫자를 변경할 때마다 관련 값들이 즉각 갱신된다.

그림의 UI를 보면 이 소프트웨어의 전반적인 기능을 파악할 수 있는데, 여기서는 비즈니스 로직 부분만 집중해서 살펴본다. 다시 말해 수익과 생산 부족분을 계산하는 클래스들만 살펴보고, HTML을 생성하고 필드 값 변경에 반응하여 밑단의 비즈니스 로직을 적용하는 코드는 생략한다. 이 장의 목적은 어디까지나 자가 테스트 코드 작성법을 파악하는 데 있다. 따라서 UI, 영속성, 외부 서비스 연동과는 관련 없는 가장 쉬운 코드부터 보는 게 합당할 것이다. 참고로 코드는 항상 이렇게 성격에 따라 분리하는 것이 좋다. 만약 여기서 살펴볼 비즈니스 로직 코드도 아주 복잡해진다면, UI와 분리하여 코드를 파악하고 테스트하기 편하게 수정했을 것이다.

비즈니스 로직 코드는 클래스 두 개로 구성된다. 하나는 생산자를 표현하는 Producer이고, 다른 하나는 지역 전체를 표현하는 Province다. Province의 생성자는 JSON 문서로부터 만들어진 자바스크립트 객체를 인수로 받는다.

JSON 데이터로부터 지역 정보를 읽어오는 코드는 다음과 같다.

- Province 클래스...
constructor(doc) {
  this._name = doc.name;
  this._producers = [];
  this._totalProduction = 0;
  this. demand = doc.demand;
  this._price = doc.price;
  doc.producers.forEach(d => this.addProducer(new Producer(this, d)));
}

addProducer (arg) {
  this._producers.push(arg);
  this._totalProduction += arg.production;
}

다음의 sampleProvinceData() 함수는 앞 생성자의 인수로 쓸 JSON 데이터를 생성한다. 이 함수를 테스트하려면 이 함수가 반환한 값을 인수로 넘겨서 Province 객체를 생성해보면 된다.

page(137)

- 최상위....
function sampleProvinceData() {
  return {
    name:"Asia",
    producers:[
      {name:"Byzantium", cost:10, production:9},
      {name:"Attalia", cost:12, production:10},
      {name:"Sinope", cost:10, production:6},
    ],
    demand:30,
    price:20
  }
}

Province 클래스에는 다양한 데이터에 대한 접근자들이 담겨 있다.

- Province 클래스...

get name() {return this._name}
get producers() {return this._producers.slice();}
get totalProduction() {return this._totalProduction;}
set totalProduction(arg) {this._totalProduction = arg;}
get demand() {return this._demand;}
set demand(arg) {this._demand = parseInt(arg);} // 숫자로 파싱해서 저장
get price() {return this._price;}
set price(arg) {this._price = parseInt(arg);} // 숫자로 파싱해서 저장

세터는 UI에서 입력한 숫자를 인수로 받는데, 이 값은 문자열로 전달된다. 그래서 계산에 활용하기 위해 숫자로 파싱한다.

Producer 클래스는 주로 단순한 데이터 저장소로 쓰인다.

- Producer 클래스...
constructor (aProvince, data) {
  this._province = aProvince;
  this._cost = data.cost;
  this._name = data.name;
  this._production = data.production ! 0;
}

get name {return this._name; }
get cost() {return this._cost;}
set cost(arg) {this._cost = parseInt(arg);}
get production() {return this._production;}
set production (amountStr) { const amount = parseInt(amountStr);
  const newProduction = Number.isNaN(amount) ? 0 : amount;
  this._province.totalProduction += newProduction - this._production;
  this._production = newProduction;
}

page(138)

set production()이 계산 결과를 지역 데이터(_province)에 갱신하는 코드가 좀 지저분하다. 나는 이런 코드를 목격하면 리팩터링해서 제거하고 싶어지지만, 그러려면 먼저 테스트를 작성해야 한다.

생산 부족분을 계산하는 코드는 간단하다.

- Province 클래스...
get shortfall() {
  return this.demand - this.totalProduction;
}

수익을 계산하는 코드는 살짝 복잡하다.
- Province 클래스...

get profit() { return this.demandValue - this.demandCost; }
get demandValue() { return this.satisfiedDemand * this.price; }
get satisfiedDemand() { return Math.min(this._demand, this.totalProduction); }
get demandCost() {
  let remainingDemand = this.demand;
  let result = 0;
  this.producers
    .sort((a,b) => a.cost-b.cost)
    .forEach(p => {
      const contribution = Math.min(remainingDemand, p.production);
      remainingDemand -= contribution;
      result += contribution * p.cost;
    });
  return result;
}


page(139)


4.3 첫 번째 테스트

이 코드를 테스트하기 위해서는 먼저 테스트 프레임워크를 마련해야 한다. 시중에는 다양한 프레임워크가 있는데, 자바스크립트용으로 나온 것만 해도 여러 개다. 여기서는 현재 널리 쓰이고 나름 좋다고 알려진 모카Mous 를 사용한다. 종합적인 사용법을 설명하기보다는 테스트 예시 몇 가지를 실행하는 모습을 바로 보여주겠다. 다른 프레임워크를 사용하더라도 비슷한 테스트를 어렵지 않게 구축할 수 있을 것이다.

다음은 생산 부족분을 제대로 계산하는지 확인하는 테스트다.

-
describe('province', function() {
  it('shortfall', function() {
    const asia = new Province(sampleProvinceData());
    // 1. 픽스처 설정
    assert.equal(asia.shortfall, S); // 2. 검증
  });
});

모카 프레임워크는 테스트 코드를 블록 단위로 나눠서 각 블록에 테스트 스위트를 담는 구조다. 테스트는 it 블록에 담긴다. 앞의 예에서는 테스트를 두 단계로 진행했다. ① 첫 번째 단계에서는 테스트에 필요한 데이터와 객체를 뜻하는 픽스처Fiature: 고정장지를 설정한다. 이 예시에서는 샘플 지역 정보로부터 생성한 Province 객체를 픽스처로 설정했다. ② 두 번째 단계에서는 이픽스처의 속성들을 검증하는데, 여기서는 주어진 초깃값에 기초하여 생산 부족분을 정확히 계산했는지 확인한다.

describe 블록과 it 블록에 부연 설명용 문자열을 써넣는 방식은 개발자마다 다르다. 테스트가 무엇을 검사하는지를 설명해 넣는 사람이 있는 반면, 마치 명확한 코드에는 주식이 필요 없는 것과 같은맥락에서 이 공간을 그냥 비워두는 사람도 있다. 나는 실패한 테스트가 무엇인지 식별할 수 있을 정도로만 작성하는 편이다.

이 테스트를 Node.js 콘솔에서 실행하면 다음과 같이 출력된다.

https://mochajs.org/

page(140)


1 passing (61ms)

피드백이 굉장히 간결하다. 보다시피 수행한 테스트와 통과한 테스트의 수만 간략히 보여준다.

실패해야 할 상황에서는 반드시 실패하게 만들자.

지금처럼 기존 코드를 검증하는 테스트를 작성했고 모두 통과했다는 건 좋은 일이다. 하지만나는 기본적으로 회의적인 인간이다. 특히 수많은 테스트를 실행했음에도 실패하는 게 없다면테스트가 내 의도와는 다른 방식으로 코드를 다루는 건 아닌지 불안해진다. 그래서 각각의 테스트가 실패하는 모습을 최소한 한 번씩은 직접 확인해본다. 이를 위해 내가 흔히 쓰는 방법은일시적으로 코드에 오류를 주입하는 것이다. 예를 들면 다음과 같다.

---- Province 클래스...
get shortfall() { return this. demand - this.totalProduction * 2; - 오류 주입 수정 후 테스트를 다시 실행하면 다음과 같이 출력된다.

0 passing (72ms)
1 failing
1) province
  shortfall:
    AssertionError: expected -20 to equal 5

at Context. (anonymous) (src/tester.js:10:12)


이처럼 모카 프레임워크를 이용하면 무언가 문제가 생겼을 때 즉시 알 수 있다. 게다가 어느 테스트가 실패했는지 짚어주고, 실패 원인을 추론해볼 수 있는 단서까지 제공한다. 이 예에서는 기대한 값과 실제로 나온 값을 단서로 제시했고, 그 원인은 물론 방금 내가 주입한 오류였다.

자주 테스트하라. 작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 적어도 하루에 한 번은 전체 테스트를 돌려보자.

page(141)

실전에서는 테스트의 수는 수천 개 이상일 수 있다. 뛰어난 테스트 프레임워크를 사용한다면 이렇게 많은 테스트도 간편하게 실행할 수 있고 무언가 실패한다면 금방 확인할 수 있다. 간결한 피드백은 자가 테스트에서 매우 중요하다. 나는 일할 때 테스트를 굉장히 자주 한다. 방금 추가한 코드에 문제가 없는지, 혹은 리팩터링하면서 실수한 것은 없는지 확인하기 위해서다.

모카 프레임워크는 소위 어서션(assertion: 단언, 확언) 라이브러리라고 하는 픽스처 검증 라이브러리를 선택해 사용할 수 있다. 현재 자바스크립트용 어서션 라이브러리는 엄청나게 많고, 그중 일부는 여러분이 이 책을 읽는 순간까지도 여전히 현역일 것이다. 이 책에서는 차이 chai 라이브러리를 사용하겠다. 차이를 사용하면 다음과 같이 assert문을 이용해 코드를 검증할 수 있다.

-
describe('province', function() {
  it('shortfall', function() {
    const asia = new Province(sampleProvinceData());
    assert.equal(asia. shortfall, 5);
  });
});

또는 다음과 같이 expect 문을 이용할 수도 있다.

describe('province', function() {
  it('shortfall', function() {
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).equal(5);
  });
});

개인적으로 assert를 선호하지만 자바스크립트를 다룰 때는 expect를 주로 사용할 것이다.

Tunnel테스트를 실행하는 방식은 테스트 환경마다 다르다. 난 자바로 프로그래밍할 때는 GUI 테스트러너 fries 를 제공하는 IDE를 사용한다. GUI 환경에서는 테스트가 실행되면 프로그레스바가 초록색으로 표시되다가 테스트 중 하나라도 실패하면 빨간색으로 바뀐다. 그래서 내 동료들은 테스트의 진행 상태를 흔히 '초록 막대stren bar'와 '빨간 막대ied'라고 부른다. 그래서 “실패한 테스트가 하나라도 있으면 리팩터링하면 안 된다”라는 의미로 흔히들 “빨간 막대일 때는 리팩

https://www.chaijs.com/


page(142)


터링하지 말라" 라고 말한다. 한편 “최근 변경을 취소하고 마지막으로 모든 테스트를 통과했던상태로 돌아가라" 라고 전하고 싶을 때는 “초록 막대로 되돌려라" 라고 말한다 (보통은 버전 관리시스템의 최근 체크포인트로 돌아가면 된다).

GUI 테스트 러너가 편하지만 반드시 필요한 것은 아니다. 나는 이맥스에서 키 하나만 누르면테스트 전체를 실행하도록 만들어 두고, 컴파일 창에 텍스트로 출력된 결과를 확인하는 방식도많이 쓴다. 핵심은 (GUI냐 콘솔이냐가 아니라) 모든 테스트가 통과했다는 사실을 빨리 알 수있다는 데 있다.

4.4 테스트 추가하기

계속해서 테스트를 더 추가해보자. 이번에는 클래스가 하는 일을 모두 살펴보고 각각의 기능에서 오류가 생길 수 있는 조건을 하나씩 테스트하는 식으로 진행하겠다. 일부 프로그래머들이선호하는 public 메서드를 빠짐없이 테스트하는 방식과는 다르다. 명심하자! 테스트는 위험요인을 중심으로 작성해야 한다! 테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를 찾는 데 있다. 따라서 단순히 필드를 읽고 쓰기만 하는 접근자는 테스트할 필요가 없다. 이런 코드는 너무 단순해서 버그가 숨어들 가능성도 별로 없다.

테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓치기 쉽기 때문에 아주 중요한 포인트다. 나는 적은 수의 테스트만으로 큰 효과를 얻고 있다. 잘못될까봐 가장 걱정되는 영역을집중적으로 테스트하는데, 이렇게 해서 테스트에 쏟는 노력의 효과를 극대화하는 것이다.

완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다.

이 맥락에서 샘플 코드의 또 다른 주요 기능인 총수익 계산 로직을 테스트해보겠다. 앞에서와마찬가지로 초기 픽스처로부터 총수익이 제대로 계산되는지 간단히 검사하도록 작성한다.

describe('province', function() { it('shortfall', function() {

const asia = new Province(sampleProvinceData());

expect(asia.shortfall).equal(5); });

Chapter 04 - 테스트 구축하기

143


it('profit', function() { const asia = new Province(sampleProvinceData()); expect(asia.profit).equal(230); }); });

여기서 내가 기댓값 230을 구한 방식은 설명이 좀 필요해 보인다. 사실 나는 먼저 기댓값 자리에 임의의 값을 넣고 테스트를 수행한 다음, 프로그램이 내놓는 실제 값 (230)으로 대체했다. 직접 손으로 계산해도 되지만, 코드가 제대로 동작할 거라 믿고 일단 이렇게 했다. 그런 다음 테스트가 제대로 작동한다고 확인되면, 총수익 계산 로직에 * 2를 덧붙여서 잘못된 값이 나오도록 수정한다. 일부러 주입한 이 오류를 테스트가 걸러내는 게 확인되면, 만족해하며 원래 코드로 되돌린다. 임시 값을 설정했다가 실제 값으로 대체하고, 오류를 심었다가 되돌리는 이 패턴은 실제로 내가 기존 코드를 검사하는 테스트를 추가할 때 흔히 쓰는 방식이다.

지금까지 작성한 두 테스트에는 겹치는 부분이 좀 있다. 둘 다 첫 줄에서 똑같은 픽스처를 설정하는 게 보일 것이다. 일반 코드와 마찬가지로 테스트 코드에서도 중복은 의심해봐야 한다. 그러니 이 픽스처를 둘 모두에서 접근할 수 있는 장소로 옮겨 중복을 제거해보자. 먼저 바깥 범위로 끌어내는 방법을 시도해보자.

describe('province', function() { const asia = new Province(sampleProvinceData()); // 이렇게 하면 안 된다. it('shortfall', function() { expect(asia.shortfall).equal(5); }); it('profit', function() { expect(asia.profit).equal(230); }); });

그런데 주석에 적은 것처럼 나는 절대로 이렇게 하지 않는다. 일시적인 효과는 있겠지만, 테스트 관련 버그 중 가장 지저분한 유형인 '테스트끼리 상호작용하게 하는 공유 픽스처'를 생성하는 원인이 된다. 자바스크립트에서 const 키워드는 asia 객체의 '내용'이 아니라 asia를 가리키는 참조가 상수임을 뜻한다. 나중에 다른 테스트에서 이 공유 객체의 값을 수정하면 이 픽스처를 사용하는 또 다른 테스트가 실패할 수 있다. 즉, 테스트를 실행하는 순서에 따라 결과가 달라질 수 있다. 이렇게 되면 테스트 결과가 제멋대로가 되어 버그를 잡기가 어렵고 오래 걸린

144 리팩터링(2판)


다. 더 심하면 테스트 자체를 믿지 못하게 된다. 그래서 나는 다음 방식을 선호한다.

> describe('province', function() { let asia; beforeEach(function() { asia = new Province(sampleProvinceData()); }); it('shortfall', function() { expect(asia.shortfall).equal (5); }); it('profit', function() { expect (asia.profit).equal(230); }); });

beforeEach 구문은 각각의 테스트 바로 전에 실행되어 asia를 초기화하기 때문에 모든 테스트가 자신만의 새로운 asia를 사용하게 된다. 이처럼 개별 테스트를 실행할 때마다 픽스처를새로 만들면 모든 테스트를 독립적으로 구성할 수 있어서, 결과를 예측할 수 없어 골치를 썩는사태를 예방할 수 있다.

내가 이렇게 조언하면 매번 픽스처를 생성하느라 테스트가 느려지지 않냐고 묻는 사람이 있다.눈에 띄게 느려지는 일은 거의 없다. 정말 문제가 될 때는 공유 픽스처를 사용하기도 하지만,이럴 때는 어떠한 테스트도 픽스처 값을 변경하지 못하도록 주의한다. 또한 불변임이 확실한픽스처는 공유하기도 한다. 그래도 가장 선호하는 방식은 매번 새로운 픽스처를 만드는 것이다. 공유 픽스처를 사용하다가 저지른 실수 때문에 디버깅하는 데 엄청난 고생을 한 경험이 많기 때문이다.

테스트마다 beforeEach 구문이 실행된다면 그 안의 코드를 각각의 it 블록에 넣으면 되지 않냐고 물을 수 있다. 나는 내 테스트들이 모두 똑같은 픽스처에 기초하여 검증을 수행하기를 바란다. 그래야 표준 픽스처에 익숙해져서 테스트할 속성을 다양하게 찾아낼 수 있기 때문이다.beforeEach 블록의 등장은 내가 표준 픽스처를 사용한다는 사실을 알려준다. 그러면 코드를읽는 이들은 해당 describe 블록 안의 모든 테스트가 똑같은 기준 데이터로부터 시작한다는사실을 쉽게 알 수 있다.

page(145)

4.5 픽스처 수정하기

지금까지 작성한 테스트 코드를 통해 픽스처를 불러와 그 속성을 확인하는 방법을 알 수 있었다. 그런데 실전에서는 사용자가 값을 변경하면서 픽스처의 내용도 수정되는 경우가 흔하다.

이러한 수정 대부분은 세터에서 이뤄지는데, 세터는 보통 아주 단순하여 버그가 생길 일도 별로 없으니 잘 테스트하지 않는다. 하지만 Producer의 production() 세터는 좀 복잡한 동작을 수행하기 때문에 테스트해볼 필요가 있다.

- describe('province ....
it("change production', function() {
  asia.producers[0].production = 20;
  expect(asia.shortfall).equal(-6);
  expect (asia.profit).equal (292);
});

흔히 보는 패턴이다. beforeEach 블록에서 '설정'한 표준 픽스처를 취해서, 테스트를 수행하고, 이 픽스처가 일을 기대한 대로 처리했는지를 검증한다. 테스트에 관해 공부를 좀 했다면 이 패턴을 설정-실행-검증, 조건-발생-결과, 준비-수행-단언 등으로 부른다는 것을 알 것이다. 이 세 가지 단계가 한 테스트 안에 모두 담겨 있을 수도 있고, 초기 준비 작업 중 공통되는 부분을 beforeEach 와 같은 표준 설정 루틴에 모아서 처리하기도 한다.

'해체' 혹은 청소"라고 하는 네 번째 단계도 있는데 명시적으로 언급하지 않을 때가 많다. 해체 단계에서는 픽스처를 제거하여 테스트들이 서로 영향을 주지 못하게 막는다. 설정을 모두 beforeEach에서 수행하도록 작성해두면, 테스트들 사이에 걸친 픽스처를 테스트 프레임워크가 알아서 해체해주기 때문에 굳이 단계를 나눌 필요는 없다. 실무에서도 해체 단계는 무시할 때가 많아서 테스트 관련 글을 보면 대부분 적당히 설명하고 넘어간다. 그런데 드물지만 해체를 명시적으로 수행해야 할 때가 있다. 특히 생성하는 데 시간이 걸려서 여러 테스트가 공유해야만 하는 픽스처가 여기 해당한다.

이 테스트는 it 구문 하나에서 두 가지 속성을 검증하고 있다. 일반적으로 it 구문 하나당 검증도 하나씩만 하는 게 좋다. 앞쪽 검증을 통과하지 못하면 나머지 검증은 실행해보지 못하고 테

page(146)

스트가 실패하게 되는데, 그러면 실패 원인을 파악하는 데 유용한 정보를 놓치기 쉽기 때문이다. 여기서는 한 테스트로 묶어도 문제되지 않을 정도로 두 속성이 밀접하다고 판단하여 이렇게 작성했다. 별개의 it 구문으로 나누고 싶다면 언제든지 나눌 수 있다.

4.6 경계 조건 검사하기

지금까지 작성한 테스트는 모든 일이 순조롭고 사용자도 우리 의도대로 사용하는, 일명 '꽃길appy pill' 상황에 집중하였다. 그런데 이 범위를 벗어나는 경계 지점에서 문제가 생기면 어떤 일이 벌어지는지 확인하는 테스트도 함께 작성하면 좋다.

나는 이번 예시의 producers와 같은 컬렉션과 마주하면 그 컬렉션이 비었을 때 어떤 일이 일어나는지 확인하는 편이다.

describe('no producers', function() { // 생산자가 없다. let noProducers; beforeEach(function() { const data = { name: "No prouducers", producers: [], demand: 30, price: 20 noProducers. = new Province(data); }); it('shortfall', function() { expect(noProducers.shortfall).equal(30); }); it('profit', function() { expect(noProducers.profit).equal(0); });

숫자형이라면 0일 때를 검사해본다.

describe('province...it('zero demand', function() { // 수요가 없다.

asia.demand = 0;

Chapter 04 - 테스트 구축하기

147


expect(asia.shortfall).equal(-25); expect(asia.profit).equal(0); });

음수도 넣어보면 좋다.

= describe('province.... it('negative demand', function() { // 수요가 마이너스다. asia.demand = -1; expect(asia.shortfall).equal(-26); expect(asia.profit).equal(-10); });

여기서 한 가지 의문이 들 수 있다. 수요가 음수일 때 수익이 음수가 나온다는 것이 이 프로그램을 사용하는 고객 관점에서 말이 되는 소리일까? 수요의 최솟값은 0이어야 하지 않나? 그래서 수요 세터에 전달된 인수가 음수라면 에러를 던지거나 무조건 0으로 설정하는 식으로 정상적인 경우와 다르게 처리해야 하지 않을까? 예리한 지적이다. 이처럼 경계를 확인하는 테스트를 작성해보면 프로그램에서 이런 특이 상황을 어떻게 처리하는 게 좋을지 생각해볼 수 있다.

문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자. 이 프로그램의 세터들은 의미상 숫자만 입력받아야 하지만 UI로부터 문자열을 취하고 있다. 그러다 보니 필드가 아예 비어 있을 수 있고, 이때도 내가 의도한 대로 잘 처리하는지 반드시 테스트해야 한다.

describe('province'... it('empty string demand', function() { // 수요 입력란이 비어 있다. asia.demand = ""; expect(asia.shortfall). NaN; expect(asia.profit). NaN; });

자, 내가 스스로 작성한 코드를 적으로 돌리고 있음이 느껴지는가? 나는 의식적으로 프로그램을 망가뜨리는 방법을 모색하는데, 이런 마음 자세가 생산성과 재미를 끌어올려준다. 내 마음속에 잠재하는 사악한 욕구를 충족시켜주기 때문인 것 같다.

이어서 흥미로운 테스트를 준비했다.

리팩터링(2판)

148


- describe('string for producers', function() { // 생산자 수 필드에 문자열을 대입한다. it('', function() { const data = { name: "String producers", producers: "", demand: 30, price: 20 }; const prov = new Province(data); expect(prov.shortfall).equal(0); });

이 테스트는 단순히 생산 부족분이 0이 아니라는 실패 메시지는 출력하는 대신, 다음과 같이 출력한다.

9 passing (74ms) 1 failing

1) string for producers : TypeError: doc.producers.forEach is not a function at new Province (src/main.js:22:19) at Context. Canonymous> (src/tester.js:86:18)

모카는 이 경우를 실패로 처리한다. 하지만 모카와 달리 에러와 실패를 구분하는 테스트 프레임워크도 많다. 실패ilure란 검증 단계에서 실제 값이 예상 범위를 벗어났다는 뜻이다. 에러ritor는 성격이 다르다. 검증보다 앞선 과정(이 예에서는 설정 단계)에서 발생한 예외 상황을 말한다. 코드 작성자가 이 상황을 미처 예상하지 못한 것이고, 그래서 자바스크립트 프로그래머라면 지긋지긋하게 보는 오류 메시지인 "... is not a function"이 출력된 것이다.

프로그램은 이 상황에 어떻게 대응해야 할까? 에러 상황을 지금보다 잘 처리하도록 코드를 추가하는 방법도 있다. 더 의미 있는 오류 메시지를 출력할 수도 있고, 그냥 (로그 메시지만 남기고) producers를 빈 배열로 설정할 수도 있다. 물론 지금 상태로 남겨둘 합당한 이유가 있을 수도 있다. 예컨대 입력 객체를 (같은 코드베이스 안처럼) 신뢰할 수 있는 곳에서 만들어주는 경우가 여기 속한다. 같은 코드베이스의 모듈 사이에 유효성 검사 alition theck 코드가 너무 많으면 다른 곳에서 확인한 걸 중복으로 검증하여 오히려 문제가 될 수 있다. 반면, JSON으로 인코

Chapter 04 - 테스트 구축하기

.!

149


딩된 요청처럼 외부에서 들어온 입력 객체는 유효한지 확인해봐야 하므로 테스트를 작성한다.어떤 경우든 경계 조건을 검사하는 테스트를 작성하다 보면 이런 고민들을 하게 된다.

나는 리팩터링하기 전이라면 이런 테스트를 작성하지 않을 것이다. 리팩터링은 겉보기 동작에영향을 주지 않아야 하며, 이런 오류는 겉보기 동작에 해당하지 않는다. 따라서 경계 조건에 대응하는 동작이 리팩터링 때문에 변하는지는 신경 쓸 필요 없다.

이런 오류로 인해 프로그램 내부에 잘못된 데이터가 흘러서 디버깅하기 어려운 문제가 발생한다면 어서션 추가하기 를 적용해서 오류가 최대한 빨리 드러나게 하자, 어서션도 일종의 테스트로 볼 수있으니 테스트 코드를 따로 작성할 필요는 없다.

어차피 모든 버그를 잡아낼 수는 없다고 생각하여 테스트를 작성하지 않는다면 대다수의 버그를잡을 수 있는 기회를 날리는 셈이다.

그렇다면 테스트를 어느 수준까지 해야 할까? 아무리 테스트해도 버그 없는 완벽한 프로그램을 만들 수는 없다는 말은 많이 들어봤을 것이다. 맞는 말이지만, 테스트가 프로그래밍 속도를높여준다는 사실에는 변함이 없다. 그동안 나는 프로그램에서 발생할 수 있는 모든 경우를 테스트하기 위한 다양한 기법을 봐왔다. 이런 기법이 도움되는 것은 분명하지만, 너무 빠져들 필요는 없다. 테스트에도 수확 체감 법칙ive of diminishing return이 적용된다. 또, 테스트를 너무 많이작성하다 보면 오히려 의욕이 떨어져 나중에는 하나도 작성하지 않게 될 위험도 있다. 따라서위험한 부분에 집중하는 게 좋다. 코드에서 처리 과정이 복잡한 부분을 찾아보자. 함수에서 오류가 생길만한 부분을 찾아보자. 테스트가 모든 버그를 걸러주지는 못할지라도, 안심하고 리팩터링할 수 있는 보호막은 되어준다. 그리고 리팩터링을 하면서 프로그램을 더욱 깊이 이해하게되어 더 많은 버그를 찾게 된다. 나는 항상 테스트 스위트부터 갖춘 뒤에 리팩터링하지만, 리팩터링하는 동안에도 계속해서 테스트를 추가한다.

150 리팩터링(2판)

1

+


4.7 끝나지 않은 여정

이 장에서 설명할 내용은 여기까지다. 결국 이 책의 주제는 테스트가 아닌 리팩터링이다. 그렇지만 테스트도 굉장히 중요한 주제다. 리팩터링에 반드시 필요한 토대일 뿐만 아니라, 그 자체로도 프로그래밍에 중요한 역할을 한다. 이 책 초판이 출간된 이후로 리팩터링이 프로그래밍 실천법 중 하나로 자리 잡는 것을 보면서 뿌듯했지만, 테스트에 대한 인식도 달라지는 것을 보니 그보다 훨씬 기뻤다. 예전에는 테스트를 별도의 (그리고 실력이 좀 떨어지는) 조직에 맡겼지만, 이제는 뛰어난 소프트웨어 개발자라면 최우선으로 관심을 가지는 주제로 떠오르고 있다. 테스트 용이성.eslabiliy 을 아키텍처 평가 기준으로 활용하는 사례도 많다.

이 장에서 보여준 테스트는 단위 테스트unitiest에 해당한다. 단위 테스트란 코드의 작은 영역만을 대상으로 빠르게 실행되도록 설계된 테스트다. 단위 테스트는 자가 테스트 코드의 핵심이자, 자가 테스트 시스템은 대부분 단위 테스트가 차지한다. 물론 컴포넌트 사이의 상호작용에 집중하는 테스트나, 소프트웨어의 다양한 계층의 연동을 검사하는 테스트, 성능 문제를 다루는 테스트 등 다양한 유형의 테스트가 있다(테스트 유형도 많지만, 유형을 분류하는 방식에 대한 논쟁은 그보다 더 많다).

다른 프로그래밍 활동과 마찬가지로 테스트도 반복적으로 진행한다. 실력이 굉장히 뛰어나거나 운이 아주 좋지 않는 한, 한 번에 완벽한 테스트를 갖출 순 없다. 나는 제품 코드에 못지않게 테스트 스위트도 지속해서 보강한다. 다시 말해 기능을 새로 추가할 때마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다. 기존 테스트가 충분히 명확한지, 테스트 과정을 더 이해하기 쉽게 리팩터링할 수는 없는지, 제대로 검사하는지 등을 확인한다. 버그를 발견하는 즉시 발견한 버그를 명확히 잡아내는 테스트부터 작성하는 습관을 들이자. 아주 중요한 습관이다! 나는 버그를 고치기 전에 항상 이런 테스트부터 만든다. 그러면 해당 버그가 다시 나타나지 않는지 확인할 수 있다. 또한 그 버그와 테스트를 계기로 테스트 스위트에 또 다른 구멍은 없는지까지 살펴본다.

버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트부터 작성하자.

“어느 정도 하면 충분히 테스트했다고 할 수 있나요?"라는 질문을 참 많이 받는다. 명확한 기준은 없다. 테스트 커버리지'est Coreruge* 를 기준으로 삼는 사람도 있지만, 테스트 커버리지 분석은 *

https://martinfowler.com/bliki/TestCoverage.html

Chapter 04 - 테스트 구축하기

151


코드에서 테스트하지 않은 영역을 찾는 데만 도움될 뿐, 테스트 스위트의 품질과는 크게 상관없다.

테스트 스위트가 충분한지를 평가하는 기준은 주관적이다. 가령 '누군가 결함을 심으면 테스트가 발견할 수 있다는 믿음'을 기준으로 할 수 있다. 이런 기준은 객관적으로 측정할 수 없어서헛된 믿음일 뿐인지 알 도리가 없다. 하지만 자가 테스트 코드의 목적은 이 믿음을 갖게 해주는것이다. 리팩터링 후 테스트 결과가 모두 초록색인 것만 보고도 리팩터링 과정에서 생겨난 버그가 하나도 없다고 확신할 수 있다면 충분히 좋은 테스트 스위트라 할 수 있다.

테스트를 너무 많이 작성할 가능성도 있다. 제품 코드보다 테스트 코드를 수정하는 데 시간이더 걸린다면, 그리고 테스트 때문에 개발 속도가 느려진다고 생각되면 테스트를 과하게 작성한건 아닌지 의심해보자. 하지만 너무 많은 경우보다는 너무 적은 경우가 훨씬 훨씬 많다.

152 리팩터링(2판)
