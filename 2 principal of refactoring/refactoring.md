## 2.1 리팩터링 정의

리팩터링: 

소프트웨어의 겉보기 동작은 그대로 유지한 채,
코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법으로
특정 방식에 따라 코드를 정리하는 것

- 함수 추출하기
- 조건부 로직을 다형성으로 바꾸기
- 함수 매개변수화하기
- ...

## 2.2 두개의 모자

소프트웨어를 개발할 때 목적에 대해
기능추가냐 아니면 리팩터링이냐를 명확히 구분해 사용한다.
10분의 짧은 작업시간이라도 하나의 목적을 가지고
작업방식의 차이를 인지해야한다.

## 2.3 필요성

1. 소프트웨어 설계가 좋아진다

리팩터링을 통해 코드의 아키텍처를 유지해야 한다.
그렇지 않다면 기반구조가 무너지게 되고,
구조가 무너지면 같은 일을 하는 코드가 여러곳에서 나타나게 된다.
그래서 중복 코드 제거는 설계 개선 작업의 중요한 한 축이다.
코드량이 줄어든다고 속도의 개선이 크게 일어나지 않않지만
수정하는데 드는 노력은 크게 달라지고,
코드가 길수록 실수없이 수정하기 어려워진다.

중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장 할 수 있으며
이는 바람직한 설계의 핵심이다.

2. 코드 이해를 쉽게 만든다
3. 버그를 쉽게 찾을 수 있다
4. 프로그래밍 속도를 높일 수 있다

나쁜설계는 로그함수처럼 개발속도가 완만해진다.
하지만 좋은 설계는 개발속도의 기울기가 줄어들지 않는다.

### 리팩터링 주기

필자는 한시간에 한번 리팩터링한다고 한다.

```
3의 법칙
1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다. 
```

## 2.4 언제 리팩터링 해야 할까?
- 준비를 위한 리팩터링 : 쉬운기능추가가 가능하게끔

'지금 위치에서 직진하다 막히면 우회전하고 20미터 가서 좌회전' <br>
지도를 보고 경로를 찾는 방법을 제시하는 리팩터링 <br>

- 이해를 위한 리팩터링
- 쓰레기 줍기 리팩터링

시간이 충분하지 않아 오랜시간 공을 들이지 않더라도 
캠핑 규칙처럼, 처음 봤을 때보다 깔끔하게 정리하고 떠나자.

- 계획된 리팩터링과 수시로 하는 리팩터링

리팩터링은 틈틈이 진행한다. 일정을 따로 잡아두지 않고 프로그래밍 과정에 자연스럽게 녹인 것.
보기 싫은 코드를 발견하면 리팩터링해야 하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야한다.
계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다. 
누군가는 버전관리 시스템에서 리팩터링 커밋과 기능추가 커밋을 분리하기도 하지만,
분리가 무조건 좋은것만은 아니다. 팀에 적합한 방식을 찾아내자.

- 오래 걸리는 리팩터링

리팩터링은 몇 분 안에, 길어야 몇 시간정도에 끝난다. 
때때로 팀 전체가 달려들어 몇 주 걸리는 대규모 리팩터링도 있다.
그렇다 해도 팀 전체가 리팩터링에 매달리는 데는 회의적이다.
주어진 문제를 몇 주에 걸쳐 조금씩 해결해 나가는 편이 효과적일 때가 많다.
리팩터링은 원하는 방향으로 조금씩 개선하는 식이다.

- 코드 리뷰에 리팩터링 활용하기

코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다.
대규모 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움된다.
다른 사람의 아이디어를 얻기 쉽다.

- 관리자에게는?

관리자는 기술적으로 리팩터링의 가치를 이해못하는 경우가 있다. 이때 리팩터링은 금기어가 된다. 
말하지 않더라도 리팩터링을 해야 소프트웨어 개발이 빨라지고 수월해진다.

- 리팩터링하지 말아야할 때

지저분한 코드를 발견해도 수정할 이유가 없다면 리팩터링 하지 않는다.
외부 api 다루듯 호출해서 쓰는 코드라면 지저분해도 상관없다.
내부동작을 이해해야 할 시점에 리팩터링 해야 효과를 제대로 볼 수 있다.
또 리팩터링 하는 것 보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링 하지 않는다.
근데 이건 경험치가 필요하다.

## 2.5 리팩터링 고려사항

### 새 기능 개발 속도 저하를 염려하는 팀원들
```
리팩터링의 궁극적인 목적은 개발 속도를 높여서 적은 노력으로 더 많은 가치를 창출하는 것 
```
 
### 코드 소유권

코드 소유권이 다른팀 혹은 외부로 나누어져 있다면 리팩터링에 방해가 된다.
이때 제약적으로 리팩터링을 한다.
예를들어 함수 이름을 변경할 때는 "함수 이름 바꾸기"를 적용하는 한편
기존 함수도 그대로 유지하되 함수 본분에서 새 함수를 호출하도록 수정한다.
인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않기 위해서는 어쩔 수 없다.

### 브랜치, 지속적인 통합

보통 팀단위 작업은 각자 브랜치를 맡아 작업하다 결과물이 어느정도 되면 마스터 브랜치에 통합해서
팀원들에게 공유한다. 이렇게 하면 어떤 기능 전체를 한 브랜치에만 구현해 놓고,
릴리즈 할 때가 돼서야 마스터에 통합하는 경우가 많다. 이를 선호하는 사람들은 미완료 코드가
마스터에 섞이지 않고 기능이 추가될 때마다 버전을 명확히 나눌 수 있고,
기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있어서 좋다고 한다.

그러나 이런 방식에는 단점이 있는데, 독립브랜치 작업시간이 길어질수록 통합이 어려워진다.
이 고통을 줄이고자 많은 이들이 수시로 머지, 리베이스한다. 

필자는 머지와 통합을 명확히 구분한다. 마스터에서 브랜치로의 머지는 단방향이지만, 
통합은 마스터를 개인 브랜치로 가져와서 작업한 결과를 다시 마스터에 올리는 처리를 말한다.

통합의 주기가 길어질 수록 통합에 처리하는 시간은 그 이상으로 필요해진다.
따라서 통합은 매우 짧은 주기로 관리해야 하고, 이 같은 방식을 지속적 통합(CI)이라 한다.
CI에 따르면 팀원들이 최소 하루에 한번은 통합을 진행한다. 

### 테스팅

리팩터링은 단계별 변경폭이 작아서 도중에 발생한 오류 코드 범위가 넓지 않다. 
리팩터링 과정에서 발생하는 오류를 빠르게 검사하기 위한 테스트 수트가 필요하다.

제스트 추천

### 레거시 코드

타인이 구현하고 물려받은 레거시 코드를 파악할 때 리팩터링이 도움된다.
대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링 하기 어렵다.
그럼 테스트를 보강해야만 한다.
테스트를 염두해두고 설계한 시스템은 쉽게 테스트 할 수 있다.

그렇지 않을 때, 쉽게 해결할 방법은 없다. 그나마 해줄 수 있는 조언은
'레거시 코드 활용 전략 -에이콘2018'에 나온 지침을 충실히 따르는 것이다.
주요내용은 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다는것이다.
이런 틈새를 만들 때도 리팩토링이 필요하고, 이 난감한 상황에서 빠져나오기 위한
쉬운 방법은 없다.

### 데이터베이스

프라모드 사달게가 개발한 진화형 데이터 베이스 설계(evolutionary database design)
과 데이터베이스 리팩터링 기법은 현재 널리 적용되고 있다.
이 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 
데이터 마이그레이션 스크립트를 작성하고 접근 코드와 데이터베이스 스키마에 대한
구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.

디비 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리즈 하는게 대체로 좋다는 점에서
다른 리팩터링과 다르다.

## 2.6 리팩터링, 아키텍처, 애그니(Yagni)

```
진화형 아키텍처 애그니
리팩터링을 활용해 향후 변화를 추측하지 않고 현재까지 파악한 요구사항만을 
해결하는 소프트 웨어를 구축한다. 단 이 요구를 멋지게 해결하도록 설계한다.
```

진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.
그 과정에서 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 진행하나, 
복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.

호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다.
필요한 시점이 되면 '함수매개변수화하기' 로 해결한다.

이런식의 설계 방식을 간결한 설계, 점진적 설계, 애그니('You Are not Going to Need It') 등으로 부른다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스

익스트림 프로그래밍(XP)의 특징은 지속적 통합, 자가테스트 코드, 리팩터링 등 
상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다.
참고로 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD) 이라 한다.

애자일 소프트웨어 방법론으로 등장한 XP는 애자일의 부흥을 이끌었다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다.
문서 작성 도중 발생한 오류를 걸러내느 테스트를 자동으로 수행할 수 있어야 한다.

## 리팩터링과 성능

'직관적인 설계 vs 성능'

리팩터링으로 인해 성능이 느려질 수 있는게 사실이다. 하지만 성능 튜닝이 더 쉬워진다.
하드리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은 리팩토링 후 성능튜닝하는것이다.

빠른 소프트웨어 작성 방법 세가지를 경험했다.

그중 가장 엄격한 방법은 시간 예산 분배 방식으로 하드리얼타임 시스템에서 많이 사용한다.
이 방식에 따르면 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다.

두 번째 방법은 끊임없이 관심을 기울이는 것이다.
그러나 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐 시스템 구조자체를 이해하지 못한 채
작성될 때도 많다. 시스템에 대해 잘 알더라도 추측하지 않고 성능을 측정해봐야 한다.
코드 전체를 고르게 최적화 해도 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다.
따라서 성능 최적화에 돌입하기 전까지 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.

성능 최적화 단계의 구체적인 절차는 다음과 같다.
먼저 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다.
그러면 성능에 큰 영향을 주는 작은 부분들을 찾을 수 있다. 그 부분을 개선한다.
최적화를 위한 수정도 작은 단계로 나눠서 진행한다.

리팩터링이 잘 되어있다면, 기능추가가 빨리 끝나서 최적화에 더 많은 시간을 할당할 수 있다.
또 성능을 더 세밀하게 분석, 프로파일러가 지적해주는 코드의 범위가 더 좁아지고, 튜닝이 쉬워진다.

## 2.9 리팩터링의 유래

커닝햄과 켄트벡은 객체지향 언어인 스몰토크를 이용해 개발해왔다. 당시 개발 환경중 리팩터링을 
활용해 보기 특히 좋았다. 두 사람의 리팩터링 아이디어가 스몰토크 커뮤니티에 큰 반향을 일으켯고
개발문화에 중요한 요소로 자리잡았다. 당시 스몰토크 커뮤니티 주도 인물중에 GoF 중 한명인 랄프가
있었고, 프레임워크와 리팩터링에 대해 연구했다. 랄프의 학생인 빌 또한 이에 관심이 많았고,
리팩터링을 다른 언어에 적용가능할거라 생각했고, 이를 이용해 박사논문을 발표했다.
이후 빌이 제기한 리팩터링 도구 아이디어를 존브랜트와 돈로버츠가 발전시켜서 스몰토크 리팩터링 도구인
리팩터링 브라우저를 개발했다.
필자는 켄트와 함께 프로젝트를 진행하며 리팩터링하는 과정을 지켜봤고, 중요성을 깨달아 자문을 구해
책의 초판을 쓰게 되었다. 이후 업계에 널리 퍼졌고, 모든 프로그래머가 리팩터링이란 용어를 
사용하게 되고 주류 개발 기법으로 자리잡았다.

## 2.10 리팩터링 자동화

인텔리제이 비주얼 스튜디오등 IDE에서도 메서드이름 전체 변경, 글로벌 함수로 전환, 지역함수 전환 등
자동화기능이 흔해졌다. 리팩터링 후 린팅 등의 기능이 완벽하기 때문에 오류를 거의 내지 않고도 
수월하게 수정이 가능하다. 

## 2.11 추가 리팩터링 자료

- 윌리엄 웨이크 "리팩터링 워크북" (인사이트 2006) 리팩터링 연습서
- 조슈아 케리에프스키 "패턴을 활용한 리팩터링" (인사이트 2006) 디자인패턴에 따른 리팩터링
- 스캇엠블러, 프라모드 사달게 "리팩토링 데이터베이스" (위키북스 2007) 디비
- 엘리엇 러스티 헤롤드 "리팩토링 HTML" (에이콘출판사 2009) 
- 마이클페더스 "레거시 코드 활용 전략" (에이콘출판사 2018) 오래된 코드 리팩터링
- 제이필즈, 셰인하비 "리팩토링:루비에디션" 루비전용


















