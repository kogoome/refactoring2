# 언제 리팩터링 하는가?


## 3.1 미스터리 네임

함수, 모듈, 변수, 클래스등의 이름만 보고도 어떤 일을 하는지 알 수 있도록 이름을 지어야 한다.

하지만 이름짓기는 프로그래밍에서 가장 어려운 두가지(캐시무효화, 이름짓기) 중 하나다.

```
함수 모듈 변수 클래스 등 이름이 시멘틱하지 않다면
- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기
을 통해 기능을 반영하여 이름을 짓도록 한다.
```


## 3.2 중복 코드

```
한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하면
- 함수 추출하기
를 사용하여 양 메서드에서 함수를 호출하게 바꾸면 된다.
```
```
코드가 비슷한데 완전히 같지 않다면
- 문장 슬라이드하기
로 비슷한 부분을 모아 "함수추출하기"를 적용할 수 있는지 살펴본다
```
```
같은 부모로부터 파생된 서브클래스들에 코드 중복이 있다면 각자 호출되지 않도록
- 메서드 올리기
를 적용해 부모로 옮긴다.
```

## 3.3 긴 함수

경험적으로 살펴볼때 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성돼며

간접호출효과

즉 코드를 이해, 공유, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오며,
주석이 필요한 부분은 무조건 함수로 만든다.
그 결과 주석이 제거되고 함수이름에 동작의도가 드러나게 한다.

```
함수의 목적과 구현 코드의 괴리가 크면 리팩토링 대상이 된다.
이때 괴리로 인해 주석이 생기는데,  
- 함수 추출하기
를 통해 리팩토링하고 주석을 이용해 함수 이름을 짓는다.
```
```
그러다 보면 리팩터링 전보다 매개변수가 많아져서 난해해질 수 있는데
- 임시 변수를 질의 함수로 바꾸기
- 매개 변수 객체 만들기
- 객체 동째로 넘기기
로 임시변수의 수를 줄이거나 매개변수의 수를 줄일 수 있다.
```
```
그럼에도 불구하고 여전히 임시 변수 매개변수가 많을때는
- 함수를 명령으로 바꾸기
를 고려하자.
```
```
조건문을 발견하면
- 조건문 분해하기
로 대응한다. 
```
```
switch의 case문마다
- 함수 추출하기
를 통해 case 본문을 함수호출문 하나로 바꾼다.
```
```
같은 조건의 스위치문이 여러개라면
- 조건부 로직 다형성으로 바꾸기
를 적용한다. 
```
```
반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만들고
이때 적합한 이름이 떠오르지 않는다면 성격이 다른 두 작업이 섞여있기 때문일 수 있다.
- 반복문 쪼개기
로 작업을 분리한다 
```

## 3.4 긴 매개변수 목록

전역 변수가 늘어나는 사태를 막으려면 매개변수로 전달하는게 합리적인 방식일 때가 있었다.
하지만 매개변수가 늘어날 수록 함수의 인풋과 아웃풋에 대해 신경써야 하는 범주가 넓어지고
이는 개발 속도를 저하시킨다.
```
다른 변수에서 값을 얻어올 수 있는 매개변수가 있을 때
-매개변수를 질의함수로 바꾸기
를통해 매개변수의 수를 줄인다
```
```
사용중인 데이터 구조에서 값을을 각각 뽑아 매개변수로 전달할때는
- 객체 통째로 넘기기
를 적용해서 원본 데이터 구조를 그대로 전달한다.
```
```
함께 전달되는 매개변수들은 
- 매개변수 객체 만들기
로 하나로 묶는다
```
```
함수의 동작 방식을 정하는 플래그 역할의 배개변수는
- 플래스 인수 제거하기 
로 없에준다
```

클래스는 매개변수를 줄이는 효과적인 수단이다.
```
특히 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다. 이때
- 여러함수를 클래스로 묶기
를 이용하여 공통 값들을 클래스의 필드로 정의한다.
(FP 에서는 일련의 부분적용함수들을 생성한다)
```

## 3.5 전역 데이터

전역데이터는 프로그램개발 시초부터 문제의 근원이었다. 전역데이터는
코드베이서 어디에서든 건드릴 수 있고 값을 누가 바꿧는지 찾아낼 메커니즘이 없다는게 문제다
전역데이터에서 문제가 발생하면 원인 코드를 찾기가 굉장히 어렵다.
전역데이터의 대표적인 형태는 전역변수지만, 
```
클래스 변수와 싱글톤에서도 같은 문제가 발생한다. 이를 방지하기 위해
- 변수 캡슐화하기
를 통해 함수로 감싸는것 만으로(클로저) 데이터 수정 요소를 
쉽게 찾고 접근을 통제할 수 있다. 
```

참고 :
- 싱글톤 패턴
어떤 클래스가 최초 한번만 메모리를 할당(static)하고 인스턴스를 만들어 사용하는 디자인 패턴
```java
public class CarClass {
    private static Carclass car = new CarClass(); 
    // 스태틱으로 하나의 인스턴스를 상주하게만든다.

    private CarClass() {}; // 생성자 접근제한 외부 사용불가
    
    // 메서드를 통해 인스턴스를 리턴받아 사용가능하게 한다.
    public static CarClass getInstance() {
        return car
    }
}
```
```javascript
class Singleton {
  static #instance 
  
  constructor() { // 생성자 접근 가능하지만
    if(Singleton.#instance) return Singleton.#instance // 단일 인스턴스를 리턴
    this.id = 1
    this.text = "hello"
    Singleton.#instance = this
  }
}
const one = new Singleton()
const two = new Singleton()
console.log(one === two) // true
```
- 캡슐화
객체의 속성(데이터필드)과 메서드를 하나로 묶고 실제 구현 내용 일부를 내부에 감추어 은닉한다.
접근제한자와 게터를 이용하여 단방향 전달 하는것을 말한다. 
굳이 필드를 캡슐화 했다면 set 함수를 만들 필요가 없다.
```javascript
class Capsule {
  #id
  name // 형식상 표기, 자바스크립트에서는 표기 안해도 무방
  constructor(name) {
    this.name = name
    this.#id = 1
  }

  get id(){return this.#id}
  #console(){console.log("print console")}
  getConsole() {this.#console()}
}

const one = new Capsule("hello")
console.log(one) // Capsule { name: 'hello' }
one.name = "world"
console.log(one) // Capsule { name: 'world' }
console.log(one.id) // 1
try {one.console()} // ide 밑줄
catch (e) {console.log(e) } // TypeError: one.console is not a function
one.getConsole() // print console
```

## 3.6 가변 데이터

한 데이터를 참조사용 하는 곳이 여러곳일 때 한 이유로 수정하면 다른곳에서 
원치않는 오류가 발생 할 수 있다. 이런 문제로 함수형프로그래밍에서는 불변데이터를 사용한다.
변경하려면 변경데이터를 넣은 복사본을 만들어 반환한다는 개념을 기본으로 한다.
```
가변데이터에 의해 위험이 생긴다면
- 변수 캡슐화하기
를 적용하여 정해놓은 함수를 거쳐야만 수정하도록 하면 값이 어떻게 수정되는지
감시 관리하기 쉽다
```
```
하나의 변수에 다른용도의 값을 저장하게 하느라 값을 갱신한다면
- 변수 쪼개기
를 이용해 독립적으로 저장하게 하는게 좋다
```
```
갱신 로직은 다른 코드와 떨어뜨려 놓는것이 좋다.
- 문장 슬라이드하기
- 함수 추출하기
를 이용해 부작용없이 코드를 분리한다
```
```
api를 만들 때는
- 질의함수와 변경함수 분리하기
를 활용한다
```
```
가능한한
- 세터 제거하기
를 이용해 변수의 유효범위를 줄인다.
```
```
값을 다른곳에서 설정할 수 있는 가변데이터가 있다면
- 파생 변수를 질의 함수로 바꾸기
를 통해 악취를 제거한다.
```
```
변수의 유효범위가 좁다면 가변데이터도 문제가 안되지만 차후 넓어질 수 있다면
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한한다.
```
```
구조체처럼 내부 필드에 데이터를 담고있는 변수는
- 참조를 값으로 바꾸기
를 적용하여 내부 필드를 수정하지 않고 구조체 통체로 교체하는 편이 낫다
```

## 3.7 뒤엉킨 변경(Divergent change)??? 번역이?? 다책임 클래스?, 

다책임 함수, 클래스는 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다.
하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많으면
모듈의 역할이 하나로 모이지 않아 발생한다. 이때는 모듈을 쪼개어 맥락별로 분리해야한다.

```
여러 역할이 한대 모여있을땐, 순차적 실행을 기준으로
- 단계 쪼개기
를 하여 역할을 분리한다.
```
```
전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면
- 함수옮기기
를 통해 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수를 모아
처리 과정을 맥락별로 구분한다.
```
```
여러 맥락의 일에 관여하는 함수가 있다면, 모듀링 클래스라면 각각
- 함수 추출하기
- 클래스 추출하기
로 맥락별로 분리한다.
```

## 3.8 샷건 수술

뒤엉킨 변경과 비슷한 악취가 나지만 정반대의 성격을 지녔다.
이 문제는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 나타난다.
샷건에 맞은것처럼 하나의 맥락이 여러 클래스들 속에 산재해 있는 경우이다.

하나의 코드를 변경했을때 변경할 부분이 코드 전반에 퍼져있다면
함께 변경되는 대상들을
-함수 옮기기
-필드 옮기기
로 모두 한 모듈에 묶는다.
```
비슷한 데이터를 다루는 함수가 많다면
- 여러 함수를 클래스로 묶기
를 적용한다.
```
```
데이터 구조를 변환, 보강하는 함수들에는
- 여러 함수를 변환함수로 묶기
를적용하여 묶어낸다.
```
```
이렇게 묶은 역할들의 출력결과를 다음단계의 로직으로 전달할 수 있다면
- 단계 쪼개기
를 적용한다
```
```
어설프게 분리된 로직을
- 함수 인라인하기
- 클래스 인라인하기
같은 인라인 리팩터링으로 합치는것도 좋은 방법이다.
```
메서드나 클래스가 비대해지지만 나중에 추출하기 리팩터링으로
더 좋은 형태로 분리 가능하다.

## 3.9 기능 편애

프로그램을 모듈화 할 때는 코드를 여러 영역으로 나누고, 
영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역간 상호작용은 최소로 줄이는데 주력한다.
기능편애는 자기 영역보다 다른 모듈의 함수나 데이터와 상호작용이 더 많을 때 발생한다.
```
실행과정에서 외부 객체의 게터 메서를 여러개 호출하는 함수를 발견한다면
- 함수 옮기기
이 함수를 데이터 근처로 옮겨주면 된다.
```
```
때로는 함수의 일부만 필요할 경우 그 부분을
- 함수 추출하기
로 독립 추출하여
- 함수 옮기기
로 원하는 모듈로 보내준다.
```
```
어디로 옮길지 명확하지 않고, 함수가 사용하는 모듈이 다양하다면
가장많은 데이터를 포함한 모듈로 옮기거나
- 함수 추출하기
로 함수를 조각으로 쪼개 각각을 옮기면 쉽게 해결된다.
```

## 3.10 데이터 뭉치

데이터들은 몰려다니기를 선호해서 한대 뭉쳐있는 경향이 있다.
데이터 뭉치인지 확인하는 방법은 데이터 하나를 줄였을때
나머지 데이터만으로 의미가 없다면 뭉치라는 뜻이다.
```
필드형태의 데이터 뭉치를 찾아서 
-클래스 추출하기
로 하나의 객체로 묶는다
```
```
메서드 시그니처에 있는 데이터 뭉치는
-매개변수 객체 만들기
-객체 통째로 넘기기
를 적용해서 매개변수를 줄인다.
```

## 3.11 기본형 집착
```
금액을 숫자형으로 계산하거나 물리량을 단위를 무시하는 경우가 많다.
-기본형을 객체로 바꾸기
를 적용하여 의미를 부여한다
```
```
기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면
-타입코드를 서브클래스로 바꾸기
-조건부 로직을 다형성으로 바꾸기
를 차례로 적용한다
```
```
기본형 그룹도 데이터 뭉치다
-클래스 추출하기
-매개변수 객체 만들기
를 이용하여 개선해준다
```

## 3.12 반복되는 switch 문

중복되는 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도
모두 찾아서 함께 수정해야 한다.
이럴 때 다형성은 반복된 switch문을 최신 스타일로 바꿔주는 세련된 무기가 된다.

## 3.13 반복문
```
-반복문을 파이프라인으로 바꾸기
를 적용하여 시대에 걸맞지 않는 반복문을 제거해주자
필터나 맵같은 연산을 사용하면 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.
```

## 3.14 성의 없는 요소
코드의 구조를 잡을 때 프로그램 요소를 이용한다.
그래야 그 구조를 변형하거나 재활용할 기회가 생기고 혹은 단순히 더 의미 있는 이름을 가졌기 때문이다.
```
하지만 그 구조가 필요없을 때가 있는데 이런 요소는 제거하는게 좋다.
이런 제거작업은
-함수 인라인하기
-클래스 인라인하기
로 처리한다. 
```
```
상속을 사용했다면 
-계층 합치기
를 적용한다
```
## 3.15 추측성 일반화

나중에 필요할거야 라는 생각으로 당장 필요없는 모든 종류의 후킹포인트와 
특이 케이스 처리 로직을 작성해둔 코드에서 발견된다. 
이해하기도 관리하기도 어려운 코드다.
```
하는일이 거의 없는 추상클래스는
-계층 합치기
로 제거한다.
```
```
쓸데없이 위임하는 코드는 
-함수 인라인하기
-클래스 인라인하기
로 삭제한다
```
```
본문에서 사용되지 않는 매개변수는
-함수 선언바꾸기
로 없엔다.
```
```
사용할 곳이 없는 함수나 클래스는
-죽은코드 제거하기
로 날려버린다.
```

## 3.16 임시 필드

특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.
보통의 클래스는 필드가 채워져있는것을 기대하기 때문에
때때로 사용되지 않는것으로 보이는 필드가 존재하는 이유를 파악하기가 어렵다.
```
이렇게 덩그러니 떨어져 있는 필드를 발견하면
-클래스 추출하기
로 제 위치를 찾아주고
-함수 옮기기
로 임시필드 관련 코드를 새클래스에 몰아넣는다.
```
```
만약 임시 필드 유효성 검사 후 동작하는 조건부 로직이 있다면
-특이 케이스 추가하기
로 필드들이 유효하지 않을 때를 위한 대안클래스를 만들어 제거할 수 있다.
```

## 3.17 메시지 체인

메시지 체인이란

클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 밤금 얻은 객체에
또다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
```
이 문제는
-위임 숨기기
로 해결한다.
```
```
위임숨기기는 메시지 체인의 다양한 연결점에 적용할 수 있지만
그러다 보면 중간 객체들이 모두 중개자가 되버릴 수 있는데
최종 결과 객체가 어떻게 쓰이는지 살펴보는게 좋다.
-함수추출하기
로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음
-함수 옮기기
로 체인을 숨길 수 있는지 살펴보자.
```

### 위임숨기기 예제
```javascript
managerName = aPerson.department.manager.name

// 위임 숨기기 적용
managerName = aPerson.department.managerName // 관리자 객체의 존재를 숨김
managerName = aPerson.manager.name // 부서 객체의 존재를 숨김
managerName = aPerson.managerName // 부서 객체와 관리자 객체 모두의 존재를 숨김

// 다음처럼 쓰일 때
managerName = aPerson.department.manager.name
report = `${managerName}께
  ${aPerson.name}님의 작업 로그 ...`
console.log(report)

// 보고서 생성 로직을 함수로 추출하고 적당한 모듈로 옮기면 체인의 존재가 감춰진다.
console.log(reportAutoGenerator.report(aPerson))
```

## 3.18 중개자
```
캡슐화는 위임이 자주 활용된다.
클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면
-중개자 제거하기
를 활용하여 실제 일을 하는 객체와 직접 소통하게 한다.
```
```
위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로
-함수인라인하기
로 정리하자.
```

## 3.19 내부자 거래
소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아하며, 그래서 모듈 사이의 데이터 거래가
많으면 결합(coupling)이 높아진다고 투덜댄다. 데이터 거래가 불가피한 경우가 있지만 그 양을 최소로 줄이고 투명하게 처리해야한다.

```
커피 자판기 옆에서 은밀히 데이터를 주고받는 모듈이 있다면
-함수옮기기
-필드옮기기
기법으로 떼어놓고 사적으로 처리하는 부분을 줄인다.
```
```
여러 모듈이 같은 관심사를 공유한다면 공통부분을 정식처리하는 모듈을 만들거나
-위임숨기기
를 이용하여 다른 모듈이 중간자 역할을 하게 한다.
```

## 3.20 거대한 클래스
```
한 클래스가 너무 많은 일을 하다보면 필드 수가 늘어나고 필드 수가 늘어나다 보면 중복코드가 생기기 쉽다. 이럴땐
-클래스 추출하기
로 필드들 일부를 따로 묶어 같은컴포넌트에 모아두는 것이 합당해 보이는 필드를 선택하면 된다.
```
```
한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보들이다.
이렇게 분리할 컴포넌트를 원래 클래스와 상속관계로 만드는게 좋다면
-슈퍼클래스 추출하기
-타입코드를 서브클래스로 바꾸기
를 적용하는 편이 쉬울 것이다.
```
```
클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 
클래스를 어떻게 쪼갤지 단서를 얻을 수도 있다. 
클라이언트들이 거대 클래스의 특정기능 그룹만 주로 사용하는지 살펴보고 유용한 기능 그룹을 찾았다면 
-클래스 추출하기
-슈퍼클래스 추출하기
-타입코드를 서브클래스로 바꾸기
등을 활용해 분리한다.
```

## 3.21 서로 다른 인터페이스의 대안 클래스들
```
클래스의 장점은 인터페이스가 같을 때 다른 클래스로 교체가 쉽다는것이다. 
-함수 선언 바꾸기
로 메서드 시그니처를 일치시키고
-함수옮기기
를 이용해 인터페이스가 같아질 때까지 필요한 동작을 클래스 안으로 넣는다.
```
```
클래스들 사이에 중복코드가 생기면 
-슈퍼클래스 추출하기
를 고려해본다
```

# 3.22 데이터 클래스

데이터 클래스란 데이터필드와 게터/세터로 구성된 클래스를 말한다.

```
변경하면 안되는 필드는
-캡슐화하기
-세터 제거하기
로 숨기고 접근을 봉쇄한다.
```
```
다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아 
-함수옮기기
로 그 메서드를 데이터 클래스로 옮길수 있는지 살펴보고 
옮기기 어렵다면
-함수 추출하기
를 이용해 옮길 수 있는 부분만 별도 메서드로 뽑는다.
```
```
데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.
이때는 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.
```
```
예외도 있는데, 다른 함수를 호출해 얻은 결과 레코드(데이터객체)로는 동작코드를 넣을 이용가 없다.
-단계쪼개기
의 결과로 나온 중단데이터 구조를 말한다. 이런 구조는 이뮤터블로, 굳이 캡슐화할 필요가 없고
이뮤터블데이터로 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.
```

## 3.23 상속 포기

서브클래스가 부모의 기능을 필요치 않는다면
```
부모에게서 서브클래스를 새로 만들고
-메서드 내리기
-필드내리기
를 활용해 물려받지 않을 부모의 기능을 모두 새로운 서브클래스로 넘겨 
부모클래스에는 공통 부분만 남긴다. 
부모 클래스는 추상클래스여야 한다고 주장하는 사람도 많다.
```
하지만 이 방식을 권하지 않는다.
열에 아홉은 냄새가 미미해서 굳이 씻어내지 않아도 된다.
상속을 포기 할 때 혼란과 문제가 생긴다면 위 방식을 사용하도록 하자.

```
서브클래스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 때 심하다.
-서브클래스를 위임으로 바꾸기
-슈퍼클래스를 위임으로 바꾸기
를 활용해 아예 상속 메커니즘에서 벗어나자.
```


## 3.24 주석

주석이 장황하게 달린 원인이 코드를 잘못작성해서인 경우가 많다.
```
특정 코드 블록이 하는 일에 주석을 남기고 싶다면 
-함수 추출하기
를 적용해본다.
```
```
이미 추출되어있는 함수임에도 여전히 설명이 필요하면
-함수 선언 바꾸기
로 함수이름을 바꾼다.
```
```
시스템이 동작하기 위한 선행조건을 명시하고 싶다면
-어서션 추가하기
를 사용한다.
```

