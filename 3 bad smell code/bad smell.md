# 언제 리팩터링 하는가?


## 3.1 미스터리 네임

함수, 모듈, 변수, 클래스등의 이름만 보고도 어떤 일을 하는지 알 수 있도록 이름을 지어야 한다.

하지만 이름짓기는 프로그래밍에서 가장 어려운 두가지(캐시무효화, 이름짓기) 중 하나다.

```
함수 모듈 변수 클래스 등 이름이 시멘틱하지 않다면
- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기
을 통해 기능을 반영하여 이름을 짓도록 한다.
```


## 3.2 중복 코드

```
한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하면
- 함수 추출하기
를 사용하여 양 메서드에서 함수를 호출하게 바꾸면 된다.
```
```
코드가 비슷한데 완전히 같지 않다면
- 문장 슬라이드하기
로 비슷한 부분을 모아 "함수추출하기"를 적용할 수 있는지 살펴본다
```
```
같은 부모로부터 파생된 서브클래스들에 코드 중복이 있다면 각자 호출되지 않도록
- 메서드 올리기
를 적용해 부모로 옮긴다.
```

## 3.3 긴 함수

경험적으로 살펴볼때 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성돼며

간접호출효과

즉 코드를 이해, 공유, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오며,
주석이 필요한 부분은 무조건 함수로 만든다.
그 결과 주석이 제거되고 함수이름에 동작의도가 드러나게 한다.

```
함수의 목적과 구현 코드의 괴리가 크면 리팩토링 대상이 된다.
이때 괴리로 인해 주석이 생기는데,  
- 함수 추출하기
를 통해 리팩토링하고 주석을 이용해 함수 이름을 짓는다.
```
```
그러다 보면 리팩터링 전보다 매개변수가 많아져서 난해해질 수 있는데
- 임시 변수를 질의 함수로 바꾸기
- 매개 변수 객체 만들기
- 객체 동째로 넘기기
로 임시변수의 수를 줄이거나 매개변수의 수를 줄일 수 있다.
```
```
그럼에도 불구하고 여전히 임시 변수 매개변수가 많을때는
- 함수를 명령으로 바꾸기
를 고려하자.
```
```
조건문을 발견하면
- 조건문 분해하기
로 대응한다. 
```
```
switch의 case문마다
- 함수 추출하기
를 통해 case 본문을 함수호출문 하나로 바꾼다.
```
```
같은 조건의 스위치문이 여러개라면
- 조건부 로직 다형성으로 바꾸기
를 적용한다. 
```
```
반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만들고
이때 적합한 이름이 떠오르지 않는다면 성격이 다른 두 작업이 섞여있기 때문일 수 있다.
- 반복문 쪼개기
로 작업을 분리한다 
```