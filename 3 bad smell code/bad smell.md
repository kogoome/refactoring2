# 언제 리팩터링 하는가?


## 3.1 미스터리 네임

함수, 모듈, 변수, 클래스등의 이름만 보고도 어떤 일을 하는지 알 수 있도록 이름을 지어야 한다.

하지만 이름짓기는 프로그래밍에서 가장 어려운 두가지(캐시무효화, 이름짓기) 중 하나다.

```
함수 모듈 변수 클래스 등 이름이 시멘틱하지 않다면
- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기
을 통해 기능을 반영하여 이름을 짓도록 한다.
```


## 3.2 중복 코드

```
한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하면
- 함수 추출하기
를 사용하여 양 메서드에서 함수를 호출하게 바꾸면 된다.
```
```
코드가 비슷한데 완전히 같지 않다면
- 문장 슬라이드하기
로 비슷한 부분을 모아 "함수추출하기"를 적용할 수 있는지 살펴본다
```
```
같은 부모로부터 파생된 서브클래스들에 코드 중복이 있다면 각자 호출되지 않도록
- 메서드 올리기
를 적용해 부모로 옮긴다.
```

## 3.3 긴 함수

경험적으로 살펴볼때 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성돼며

간접호출효과

즉 코드를 이해, 공유, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오며,
주석이 필요한 부분은 무조건 함수로 만든다.
그 결과 주석이 제거되고 함수이름에 동작의도가 드러나게 한다.

```
함수의 목적과 구현 코드의 괴리가 크면 리팩토링 대상이 된다.
이때 괴리로 인해 주석이 생기는데,  
- 함수 추출하기
를 통해 리팩토링하고 주석을 이용해 함수 이름을 짓는다.
```
```
그러다 보면 리팩터링 전보다 매개변수가 많아져서 난해해질 수 있는데
- 임시 변수를 질의 함수로 바꾸기
- 매개 변수 객체 만들기
- 객체 동째로 넘기기
로 임시변수의 수를 줄이거나 매개변수의 수를 줄일 수 있다.
```
```
그럼에도 불구하고 여전히 임시 변수 매개변수가 많을때는
- 함수를 명령으로 바꾸기
를 고려하자.
```
```
조건문을 발견하면
- 조건문 분해하기
로 대응한다. 
```
```
switch의 case문마다
- 함수 추출하기
를 통해 case 본문을 함수호출문 하나로 바꾼다.
```
```
같은 조건의 스위치문이 여러개라면
- 조건부 로직 다형성으로 바꾸기
를 적용한다. 
```
```
반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만들고
이때 적합한 이름이 떠오르지 않는다면 성격이 다른 두 작업이 섞여있기 때문일 수 있다.
- 반복문 쪼개기
로 작업을 분리한다 
```

## 3.4 긴 매개변수 목록

전역 변수가 늘어나는 사태를 막으려면 매개변수로 전달하는게 합리적인 방식일 때가 있었다.
하지만 매개변수가 늘어날 수록 함수의 인풋과 아웃풋에 대해 신경써야 하는 범주가 넓어지고
이는 개발 속도를 저하시킨다.
```
다른 변수에서 값을 얻어올 수 있는 매개변수가 있을 때
-매개변수를 질의함수로 바꾸기
를통해 매개변수의 수를 줄인다
```
```
사용중인 데이터 구조에서 값을을 각각 뽑아 매개변수로 전달할때는
- 객체 통째로 넘기기
를 적용해서 원본 데이터 구조를 그대로 전달한다.
```
```
함께 전달되는 매개변수들은 
- 매개변수 객체 만들기
로 하나로 묶는다
```
```
함수의 동작 방식을 정하는 플래그 역할의 배개변수는
- 플래스 인수 제거하기 
로 없에준다
```

클래스는 매개변수를 줄이는 효과적인 수단이다.
```
특히 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다. 이때
- 여러함수를 클래스로 묶기
를 이용하여 공통 값들을 클래스의 필드로 정의한다.
(FP 에서는 일련의 부분적용함수들을 생성한다)
```

## 3.5 전역 데이터

전역데이터는 프로그램개발 시초부터 문제의 근원이었다. 전역데이터는
코드베이서 어디에서든 건드릴 수 있고 값을 누가 바꿧는지 찾아낼 메커니즘이 없다는게 문제다
전역데이터에서 문제가 발생하면 원인 코드를 찾기가 굉장히 어렵다.
전역데이터의 대표적인 형태는 전역변수지만, 
```
클래스 변수와 싱글톤에서도 같은 문제가 발생한다. 이를 방지하기 위해
- 변수 캡슐화하기
를 통해 함수로 감싸는것 만으로(클로저) 데이터 수정 요소를 
쉽게 찾고 접근을 통제할 수 있다. 
```

참고 :
- 싱글톤 패턴
어떤 클래스가 최초 한번만 메모리를 할당(static)하고 인스턴스를 만들어 사용하는 디자인 패턴
```java
public class CarClass {
    private static Carclass car = new CarClass(); 
    // 스태틱으로 하나의 인스턴스를 상주하게만든다.

    private CarClass() {}; // 생성자 접근제한 외부 사용불가
    
    // 메서드를 통해 인스턴스를 리턴받아 사용가능하게 한다.
    public static CarClass getInstance() {
        return car
    }
}
```
```javascript
class Singleton {
  static #instance 
  
  constructor() { // 생성자 접근 가능하지만
    if(Singleton.#instance) return Singleton.#instance // 단일 인스턴스를 리턴
    this.id = 1
    this.text = "hello"
    Singleton.#instance = this
  }
}
const one = new Singleton()
const two = new Singleton()
console.log(one === two) // true
```
- 캡슐화
객체의 속성(데이터필드)과 메서드를 하나로 묶고 실제 구현 내용 일부를 내부에 감추어 은닉한다.
접근제한자와 게터를 이용하여 단방향 전달 하는것을 말한다. 
굳이 필드를 캡슐화 했다면 set 함수를 만들 필요가 없다.
```javascript
class Capsule {
  #id
  name // 형식상 표기, 자바스크립트에서는 표기 안해도 무방
  constructor(name) {
    this.name = name
    this.#id = 1
  }

  get id(){return this.#id}
  #console(){console.log("print console")}
  getConsole() {this.#console()}
}

const one = new Capsule("hello")
console.log(one) // Capsule { name: 'hello' }
one.name = "world"
console.log(one) // Capsule { name: 'world' }
console.log(one.id) // 1
try {one.console()} // ide 밑줄
catch (e) {console.log(e) } // TypeError: one.console is not a function
one.getConsole() // print console
```

## 3.6 가변 데이터

한 데이터를 참조사용 하는 곳이 여러곳일 때 한 이유로 수정하면 다른곳에서 
원치않는 오류가 발생 할 수 있다. 이런 문제로 함수형프로그래밍에서는 불변데이터를 사용한다.
변경하려면 변경데이터를 넣은 복사본을 만들어 반환한다는 개념을 기본으로 한다.
```
가변데이터에 의해 위험이 생긴다면
- 변수 캡슐화하기
를 적용하여 정해놓은 함수를 거쳐야만 수정하도록 하면 값이 어떻게 수정되는지
감시 관리하기 쉽다
```
```
하나의 변수에 다른용도의 값을 저장하게 하느라 값을 갱신한다면
- 변수 쪼개기
를 이용해 독립적으로 저장하게 하는게 좋다
```
```
갱신 로직은 다른 코드와 떨어뜨려 놓는것이 좋다.
- 문장 슬라이드하기
- 함수 추출하기
를 이용해 부작용없이 코드를 분리한다
```
```
api를 만들 때는
- 질의함수와 변경함수 분리하기
를 활용한다
```
```
가능한한
- 세터 제거하기
를 이용해 변수의 유효범위를 줄인다.
```
```
값을 다른곳에서 설정할 수 있는 가변데이터가 있다면
- 파생 변수를 질의 함수로 바꾸기
를 통해 악취를 제거한다.
```
```
변수의 유효범위가 좁다면 가변데이터도 문제가 안되지만 차후 넓어질 수 있다면
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한한다.
```
```
구조체처럼 내부 필드에 데이터를 담고있는 변수는
- 참조를 값으로 바꾸기
를 적용하여 내부 필드를 수정하지 않고 구조체 통체로 교체하는 편이 낫다
```

## 3.7 뒤엉킨 변경(Divergent change)??? 번역이?? 다책임 클래스?, 

다책임 함수, 클래스는 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다.
하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많으면
모듈의 역할이 하나로 모이지 않아 발생한다. 이때는 모듈을 쪼개어 맥락별로 분리해야한다.

```
여러 역할이 한대 모여있을땐, 순차적 실행을 기준으로
- 단계 쪼개기
를 하여 역할을 분리한다.
```
```
전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면
- 함수옮기기
를 통해 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수를 모아
처리 과정을 맥락별로 구분한다.
```
```
여러 맥락의 일에 관여하는 함수가 있다면, 모듀링 클래스라면 각각
- 함수 추출하기
- 클래스 추출하기
로 맥락별로 분리한다.
```

## 3.8 샷건 수술

뒤엉킨 변경과 비슷한 악취가 나지만 정반대의 성격을 지녔다.
이 문제는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 나타난다.
샷건에 맞은것처럼 하나의 맥락이 여러 클래스들 속에 산재해 있는 경우이다.

하나의 코드를 변경했을때 변경할 부분이 코드 전반에 퍼져있다면
함께 변경되는 대상들을
-함수 옮기기
-필드 옮기기
로 모두 한 모듈에 묶는다.
```
비슷한 데이터를 다루는 함수가 많다면
- 여러 함수를 클래스로 묶기
를 적용한다.
```
```
데이터 구조를 변환, 보강하는 함수들에는
- 여러 함수를 변환함수로 묶기
를적용하여 묶어낸다.
```
```
이렇게 묶은 역할들의 출력결과를 다음단계의 로직으로 전달할 수 있다면
- 단계 쪼개기
를 적용한다
```
```
어설프게 분리된 로직을
- 함수 인라인하기
- 클래스 인라인하기
같은 인라인 리팩터링으로 합치는것도 좋은 방법이다.
```
메서드나 클래스가 비대해지지만 나중에 추출하기 리팩터링으로
더 좋은 형태로 분리 가능하다.

## 3.9 기능 편애

프로그램을 모듈화 할 때는 코드를 여러 영역으로 나누고, 
영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역간 상호작용은 최소로 줄이는데 주력한다.
기능편애는 자기 영역보다 다른 모듈의 함수나 데이터와 상호작용이 더 많을 때 발생한다.
```
실행과정에서 외부 객체의 게터 메서를 여러개 호출하는 함수를 발견한다면
- 함수 옮기기
이 함수를 데이터 근처로 옮겨주면 된다.
```
```
때로는 함수의 일부만 필요할 경우 그 부분을
- 함수 추출하기
로 독립 추출하여
- 함수 옮기기
로 원하는 모듈로 보내준다.
```
```
어디로 옮길지 명확하지 않고, 함수가 사용하는 모듈이 다양하다면
가장많은 데이터를 포함한 모듈로 옮기거나
- 함수 추출하기
로 함수를 조각으로 쪼개 각각을 옮기면 쉽게 해결된다.
```

## 3.10 데이터 뭉치

데이터들은 몰려다니기를 선호해서 한대 뭉쳐있는 경향이 있다.
데이터 뭉치인지 확인하는 방법은 데이터 하나를 줄였을때
나머지 데이터만으로 의미가 없다면 뭉치라는 뜻이다.
```
필드형태의 데이터 뭉치를 찾아서 
-클래스 추출하기
로 하나의 객체로 묶는다
```
```
메서드 시그니처에 있는 데이터 뭉치는
-매개변수 객체 만들기
-객체 통째로 넘기기
를 적용해서 매개변수를 줄인다.
```

## 3.11 기본형 집착
